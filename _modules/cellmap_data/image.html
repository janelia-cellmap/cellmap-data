
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cellmap_data.image &#8212; CellMap-Data</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=e645c8fa"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/cellmap_data/image';</script>
    <link rel="icon" href="https://raw.githubusercontent.com/janelia-cellmap/cellmap-data/main/docs/source/_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="https://raw.githubusercontent.com/janelia-cellmap/cellmap-data/main/docs/source/_static/CellMapLogo.png" class="logo__image only-light" alt="CellMap-Data - Home"/>
    <img src="https://raw.githubusercontent.com/janelia-cellmap/cellmap-data/main/docs/source/_static/CellMapLogo.png" class="logo__image only-dark pst-js-only" alt="CellMap-Data - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../index.html">
                    CellMap-Data: the Docs
                </a>
            </li>
        </ul>
        
    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for cellmap_data.image</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tensorstore</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray_tensorstore</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">zarr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydantic_ome_ngff.v04.axis</span><span class="w"> </span><span class="kn">import</span> <span class="n">Axis</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydantic_ome_ngff.v04.multiscale</span><span class="w"> </span><span class="kn">import</span> <span class="n">MultiscaleGroupAttrs</span><span class="p">,</span> <span class="n">MultiscaleMetadata</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pydantic_ome_ngff.v04.transform</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Scale</span><span class="p">,</span>
    <span class="n">Translation</span><span class="p">,</span>
    <span class="n">VectorScale</span><span class="p">,</span>
    <span class="n">VectorTranslation</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">rot</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">upath</span><span class="w"> </span><span class="kn">import</span> <span class="n">UPath</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">xarray_ome_ngff.v04.multiscale</span><span class="w"> </span><span class="kn">import</span> <span class="n">coords_from_transforms</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">cellmap_data.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_multiscale_metadata</span>


<div class="viewcode-block" id="CellMapImage">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.CellMapImage">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CellMapImage</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for handling image data from a CellMap dataset.</span>

<span class="sd">    This class is used to load image data from a CellMap dataset, and can apply spatial transformations to the data. It also handles the loading of the image data from the dataset, and can apply value transformations to the data. The image data is returned as a PyTorch tensor formatted for use in training, and can be loaded onto a specified device.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        path (str): The path to the multiscale image file.</span>
<span class="sd">        label_class (str): The label class of the image.</span>
<span class="sd">        scale (Mapping[str, float]): The scale of the image in physical space.</span>
<span class="sd">        output_shape (Mapping[str, int]): The shape of data returned from image queries in voxels.</span>
<span class="sd">        axes (str): The order of the axes in the image.</span>
<span class="sd">        value_transform (Optional[Callable]): A function to transform the image data, such as adding gaussian noise.</span>
<span class="sd">        context (Optional[tensorstore.Context]): The context for the TensorStore.</span>

<span class="sd">    Methods:</span>
<span class="sd">        __getitem__(center: Mapping[str, float]) -&gt; torch.Tensor: Returns image data centered around the given point.</span>
<span class="sd">        __repr__() -&gt; str: Returns a string representation of the CellMapImage object.</span>
<span class="sd">        apply_spatial_transforms(coords: Mapping[str, Sequence[float]]) -&gt; torch.Tensor: Applies spatial transformations to the given coordinates and returns the tensor of the resulting data.</span>
<span class="sd">        return_data(coords: Mapping[str, Sequence[float]]) -&gt; xarray.DataArray: Pulls data from the image based on the given coordinates and returns the data as an xarray DataArray.</span>
<span class="sd">        set_spatial_transforms(transforms: Mapping[str, Any] | None): Sets spatial transformations for the image data, used for setting uniform transformations to all images within a dataset.</span>
<span class="sd">        to(device: str): Sets what device returned image data will be loaded onto.</span>

<span class="sd">    Properties:</span>

<span class="sd">        shape (Mapping[str, int]): Returns the shape of the image in voxels.</span>
<span class="sd">        center (Mapping[str, float]): Returns the center of the image in world units.</span>
<span class="sd">        multiscale_attrs: Returns CellMap specified multiscale metadata of the image.</span>
<span class="sd">        coordinateTransformations: Returns the coordinate transformations of the image specified in its metadata (e.g. scale and translation).</span>
<span class="sd">        full_coords: Returns the full coordinates of the image in world units.</span>
<span class="sd">        scale_level (str): Returns the path extension for the multiscale level of the image (e.g. &#39;s0&#39;).</span>
<span class="sd">        group (zarr.Group): Returns the multiscale zarr group object for the image.</span>
<span class="sd">        array_path (str): Returns the path to the single-scale image array.</span>
<span class="sd">        array (xarray.DataArray): Returns the image data as an xarray DataArray.</span>
<span class="sd">        translation (Mapping[str, float]): Returns the translation of the image in world units.</span>
<span class="sd">        bounding_box (Mapping[str, list[float]]): Returns the bounding box of the dataset in world units.</span>
<span class="sd">        sampling_box (Mapping[str, list[float]]): Returns the sampling box of the dataset in world units.</span>
<span class="sd">        bg_count (float): Returns the number of background pixels in the ground truth data, normalized by the resolution.</span>
<span class="sd">        class_counts (float): Returns the number of pixels for the contained class in the ground truth data, normalized by the resolution.</span>
<span class="sd">        device (str): Returns the device that the image data will be loaded onto.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CellMapImage.__init__">
<a class="viewcode-back" href="../../cellmap_data.CellMapImage.html#cellmap_data.CellMapImage.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">target_class</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">target_scale</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">target_voxel_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">pad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">pad_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">interpolation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="n">axis_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;zyx&quot;</span><span class="p">,</span>
        <span class="n">value_transform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tensorstore</span><span class="o">.</span><span class="n">Context</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes a CellMapImage object.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str): The path to the image file.</span>
<span class="sd">            target_class (str): The label class of the image.</span>
<span class="sd">            target_scale (Sequence[float]): The scale of the image data to return in physical space.</span>
<span class="sd">            target_voxel_shape (Sequence[int]): The shape of the image data to return in voxels.</span>
<span class="sd">            axis_order (str, optional): The order of the axes in the image. Defaults to &quot;zyx&quot;.</span>
<span class="sd">            value_transform (Optional[callable], optional): A function to transform the image pixel data. Defaults to None.</span>
<span class="sd">            context (Optional[tensorstore.Context], optional): The context for the image data. Defaults to None.</span>
<span class="sd">            device (Optional[str | torch.device], optional): The device to load the image data onto. Defaults to &quot;cuda&quot; if available, then &quot;mps&quot;, then &quot;cpu&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_class</span> <span class="o">=</span> <span class="n">target_class</span>
        <span class="c1"># TODO: Below makes assumptions about image scale, and also locks which axis is sliced to 2D</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_order</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_scale</span><span class="p">):</span>
            <span class="n">target_scale</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">axis_order</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_scale</span><span class="p">)</span>
            <span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">target_scale</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_order</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_voxel_shape</span><span class="p">):</span>
            <span class="n">target_voxel_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">axis_order</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_voxel_shape</span><span class="p">)</span>
            <span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">target_voxel_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad</span> <span class="o">=</span> <span class="n">pad</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad_value</span> <span class="o">=</span> <span class="n">pad_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="n">interpolation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axis_order</span><span class="p">,</span> <span class="n">target_scale</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">t</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axis_order</span><span class="p">,</span> <span class="n">target_voxel_shape</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">:</span> <span class="n">t</span> <span class="o">*</span> <span class="n">s</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axis_order</span><span class="p">,</span> <span class="n">target_voxel_shape</span><span class="p">,</span> <span class="n">target_scale</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="n">axis_order</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_voxel_shape</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value_transform</span> <span class="o">=</span> <span class="n">value_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_spatial_transforms</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_center</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="k">elif</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="s2">&quot;cuda&quot;</span>
        <span class="k">elif</span> <span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">mps</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="s2">&quot;mps&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="s2">&quot;cpu&quot;</span></div>


<div class="viewcode-block" id="CellMapImage.__getitem__">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.CellMapImage.__getitem__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns image data centered around the given point, based on the scale and shape of the target output image.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_center</span> <span class="o">=</span> <span class="n">center</span>

            <span class="c1"># Find vectors of coordinates in world space to pull data from</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># raise ValueError(</span>
                    <span class="ne">UserWarning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Center </span><span class="si">{</span><span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="si">}</span><span class="s2"> is out of bounds for axis </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2"> in image </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="si">}</span><span class="s2"> would be less than </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="c1"># center[c] = self.bounding_box[c][0] + self.output_size[c] / 2</span>
                <span class="k">if</span> <span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># raise ValueError(</span>
                    <span class="ne">UserWarning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Center </span><span class="si">{</span><span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="si">}</span><span class="s2"> is out of bounds for axis </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2"> in image </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="si">}</span><span class="s2"> would be greater than </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="c1"># center[c] = self.bounding_box[c][1] - self.output_size[c] / 2</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                    <span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="n">c</span><span class="p">],</span>
                <span class="p">)</span>

            <span class="c1"># Apply any spatial transformations to the coordinates and return the image data as a PyTorch tensor</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_spatial_transforms</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_center</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_coords</span> <span class="o">=</span> <span class="n">center</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_coords</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Apply any value transformations to the data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_transform</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a string representation of the CellMapImage object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;CellMapImage(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">array_path</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the shape of the image.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">c</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_level</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the center of the image in world units.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">multiscale_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MultiscaleMetadata</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the multiscale metadata of the image.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiscale_attrs</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_multiscale_attrs</span><span class="p">:</span> <span class="n">MultiscaleMetadata</span> <span class="o">=</span> <span class="n">MultiscaleGroupAttrs</span><span class="p">(</span>
                <span class="n">multiscales</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;multiscales&quot;</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">multiscales</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiscale_attrs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coordinateTransformations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Scale</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Scale</span><span class="p">,</span> <span class="n">Translation</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the coordinate transformations of the image, based on the multiscale metadata.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinateTransformations</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># multi_tx = multi.coordinateTransformations</span>
            <span class="n">dset</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">ds</span>
                <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiscale_attrs</span><span class="o">.</span><span class="n">datasets</span>
                <span class="k">if</span> <span class="n">ds</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_level</span>
            <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># tx_fused = normalize_transforms(multi_tx, dset.coordinateTransformations)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coordinateTransformations</span> <span class="o">=</span> <span class="n">dset</span><span class="o">.</span><span class="n">coordinateTransformations</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinateTransformations</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the full coordinates of the image&#39;s axes in world units.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_coords</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_full_coords</span> <span class="o">=</span> <span class="n">coords_from_transforms</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">multiscale_attrs</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">transforms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinateTransformations</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
                <span class="c1"># transforms=tx_fused,</span>
                <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_level</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_coords</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">scale_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the multiscale level of the image.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_level</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_level</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_level</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">group</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">zarr</span><span class="o">.</span><span class="n">Group</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the zarr group object for the multiscale image.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;s3://&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span>
                    <span class="n">zarr</span><span class="o">.</span><span class="n">N5FSStore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">anon</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">array_path</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the path to the single-scale image array.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_path</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_array_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_level</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_path</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the image data as an xarray DataArray.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># Construct an xarray with Tensorstore backend</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="n">xt</span><span class="o">.</span><span class="n">_zarr_spec_from_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_path</span><span class="p">)</span>
            <span class="n">array_future</span> <span class="o">=</span> <span class="n">tensorstore</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
                <span class="n">spec</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span>
            <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array_future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="ne">Warning</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="ne">UserWarning</span><span class="p">(</span><span class="s2">&quot;Falling back to zarr3 driver&quot;</span><span class="p">)</span>
                <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;driver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;zarr3&quot;</span>
                <span class="n">array_future</span> <span class="o">=</span> <span class="n">tensorstore</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
                    <span class="n">spec</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span>
                <span class="p">)</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array_future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">xt</span><span class="o">.</span><span class="n">_TensorStoreAdapter</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_array</span> <span class="o">=</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">full_coords</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">translation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the translation of the image.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># Get the translation of the image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_translation</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">}</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the bounding box of the dataset in world units.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_coords</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">coord</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sampling_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sampling box of the dataset (i.e. where centers can be drawn from and still have full samples drawn from within the bounding box), in world units.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">output_padding</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">start</span> <span class="o">+</span> <span class="n">output_padding</span><span class="p">[</span><span class="n">c</span><span class="p">],</span>
                    <span class="n">stop</span> <span class="o">-</span> <span class="n">output_padding</span><span class="p">[</span><span class="n">c</span><span class="p">],</span>
                <span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Sampling box for axis </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2"> is invalid: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="si">}</span><span class="s2"> for image </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">. Image is not large enough to sample from as requested.&quot;</span>
                <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">c</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">c</span><span class="p">],</span>
                        <span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">raise</span> <span class="n">e</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bg_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of background pixels in the ground truth data, normalized by the resolution.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bg_count</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># Get from cellmap-schemas metadata, then normalize by resolution - get class counts at same time</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_counts</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bg_count</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">class_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of pixels for the contained class in the ground truth data, normalized by the resolution.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_counts</span>  <span class="c1"># type: ignore</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># Get from cellmap-schemas metadata, then normalize by resolution</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bg_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">[</span><span class="s2">&quot;s0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;cellmap&quot;</span><span class="p">][</span><span class="s2">&quot;annotation&quot;</span><span class="p">][</span>
                    <span class="s2">&quot;complement_counts&quot;</span>
                <span class="p">][</span><span class="s2">&quot;absent&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">scale</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;multiscales&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;datasets&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">scale</span><span class="p">[</span><span class="s2">&quot;path&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;s0&quot;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">transform</span> <span class="ow">in</span> <span class="n">scale</span><span class="p">[</span><span class="s2">&quot;coordinateTransformations&quot;</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="s2">&quot;scale&quot;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
                                <span class="n">s0_scale</span> <span class="o">=</span> <span class="n">transform</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span>
                                <span class="k">break</span>
                        <span class="k">break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_class_counts</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">[</span><span class="s2">&quot;s0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">bg_count</span>
                <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">s0_scale</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bg_count</span> <span class="o">=</span> <span class="n">bg_count</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">s0_scale</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to get class counts for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># print(&quot;from metadata, falling back to giving foreground 1 pixel, and the rest to background.&quot;)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_class_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bg_count</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_level</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_counts</span>  <span class="c1"># type: ignore</span>

<div class="viewcode-block" id="CellMapImage.to">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.CellMapImage.to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets what device returned image data will be loaded onto.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span></div>


<div class="viewcode-block" id="CellMapImage.find_level">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.CellMapImage.find_level">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_scale</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Finds the multiscale level that is closest to the target scale.&quot;&quot;&quot;</span>
        <span class="c1"># Get the order of axes in the image</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;multiscales&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;axes&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">axis</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;space&quot;</span><span class="p">:</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axis</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>

        <span class="n">last_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;multiscales&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;datasets&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">transform</span> <span class="ow">in</span> <span class="n">level</span><span class="p">[</span><span class="s2">&quot;coordinateTransformations&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="s2">&quot;scale&quot;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
                    <span class="n">scale</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">transform</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">])}</span>
                    <span class="k">break</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">scale</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target_scale</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">last_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">level</span><span class="p">[</span><span class="s2">&quot;path&quot;</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">last_path</span>
            <span class="n">last_path</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="s2">&quot;path&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">last_path</span>  <span class="c1"># type: ignore</span></div>


<div class="viewcode-block" id="CellMapImage.rotate_coords">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.CellMapImage.rotate_coords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate_coords</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">angles</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotates the given coordinates by the given angles.&quot;&quot;&quot;</span>
        <span class="c1"># Check to see if a rotation is necessary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="k">return</span> <span class="n">coords</span>

        <span class="c1"># Convert the coordinates dictionary to a vector</span>
        <span class="n">coords_vector</span><span class="p">,</span> <span class="n">axes_lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_dict_to_vector</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="c1"># Recenter the coordinates around the origin</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">coords_vector</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">coords_vector</span> <span class="o">-=</span> <span class="n">center</span>

        <span class="n">rotation_vector</span> <span class="o">=</span> <span class="p">[</span><span class="n">angles</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">angles</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span>
        <span class="n">rotator</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotation_vector</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Apply the rotation</span>
        <span class="n">rotated_coords</span> <span class="o">=</span> <span class="n">rotator</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords_vector</span><span class="p">)</span>

        <span class="c1"># Recenter the coordinates around the original center</span>
        <span class="n">rotated_coords</span> <span class="o">+=</span> <span class="n">center</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord_vector_to_grid_dict</span><span class="p">(</span><span class="n">rotated_coords</span><span class="p">,</span> <span class="n">axes_lengths</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_coord_dict_to_vector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coords_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts a dictionary of coordinates to a vector, for use with rotate_coords.&quot;&quot;&quot;</span>
        <span class="n">coord_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">coords_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))</span>
        <span class="n">axes_lengths</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_dict</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">coord_vector</span><span class="p">,</span> <span class="n">axes_lengths</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_coord_vector_to_grid_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coords_vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">axes_lengths</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts a vector of coordinates to a grid type dictionary.&quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes_lengths</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span>
        <span class="n">coords_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">:</span> <span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">coords_vector</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">coords_dict</span>

<div class="viewcode-block" id="CellMapImage.set_spatial_transforms">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.CellMapImage.set_spatial_transforms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_spatial_transforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transforms</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets spatial transformations for the image data, for setting global transforms at the &#39;dataset&#39; level.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_spatial_transforms</span> <span class="o">=</span> <span class="n">transforms</span></div>


<div class="viewcode-block" id="CellMapImage.apply_spatial_transforms">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.CellMapImage.apply_spatial_transforms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_spatial_transforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies spatial transformations to the given coordinates.&quot;&quot;&quot;</span>
        <span class="c1"># Apply spatial transformations to the coordinates</span>
        <span class="c1"># Because some spatial transformations require the image array, we need to apply them after pulling the data. This is done by separating the transforms into two groups</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_spatial_transforms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Because of the implementation details, we explicitly apply transforms in a specific order</span>
            <span class="k">if</span> <span class="s2">&quot;mirror&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_spatial_transforms</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_spatial_transforms</span><span class="p">[</span><span class="s2">&quot;mirror&quot;</span><span class="p">]:</span>
                    <span class="c1"># Assumes the coords are the default xarray format</span>
                    <span class="n">coords</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">axis</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;rotate&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_spatial_transforms</span><span class="p">:</span>
                <span class="c1"># Assumes the coords are the default xarray format, and that the rotation is in degrees</span>
                <span class="c1"># Converts the coordinates to a vector, rotates them, then converts them to a grid dictionary</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_coords</span><span class="p">(</span>
                    <span class="n">coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_spatial_transforms</span><span class="p">[</span><span class="s2">&quot;rotate&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;deform&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_spatial_transforms</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Deformations are not yet implemented.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_coords</span> <span class="o">=</span> <span class="n">coords</span>

        <span class="c1"># Pull data from the image</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_data</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># Apply and spatial transformations that require the image array (e.g. transpose)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_spatial_transforms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">transform</span><span class="p">,</span> <span class="n">params</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_spatial_transforms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># if transform in self.post_image_transforms:</span>
                <span class="k">if</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;transpose&quot;</span><span class="p">:</span>
                    <span class="n">new_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">new_order</span><span class="p">)</span>
                    <span class="c1"># else:</span>
                    <span class="c1">#     raise ValueError(f&quot;Unknown spatial transform: {transform}&quot;)</span>

        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="CellMapImage.return_data">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.CellMapImage.return_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">return_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span>
            <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span>
        <span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pulls data from the image based on the given coordinates, applying interpolation if necessary, and returns the data as an xarray DataArray.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolation</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                <span class="o">**</span><span class="n">coords</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                <span class="n">tolerance</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
                <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pad_value</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
                <span class="o">**</span><span class="n">coords</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>
</div>



<div class="viewcode-block" id="EmptyImage">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.EmptyImage">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EmptyImage</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for handling empty image data.</span>

<span class="sd">    This class is used to create an empty image object, which can be used as a placeholder for images that do not exist in the dataset. It can be used to maintain a consistent API for image objects even when no data is present.</span>

<span class="sd">    Attributes:</span>

<span class="sd">        label_class (str): The intended label class of the image.</span>
<span class="sd">        target_scale (Sequence[float]): The intended scale of the image in physical space.</span>
<span class="sd">        target_voxel_shape (Sequence[int]): The intended shape of the image in voxels.</span>
<span class="sd">        store (Optional[torch.Tensor]): The tensor to return.</span>
<span class="sd">        axis_order (str): The intended order of the axes in the image.</span>
<span class="sd">        empty_value (float | int): The value to fill the image with.</span>

<span class="sd">    Methods:</span>

<span class="sd">        __getitem__(center: Mapping[str, float]) -&gt; torch.Tensor: Returns the empty image data.</span>
<span class="sd">        to(device: str): Moves the image data to the given device.</span>
<span class="sd">        set_spatial_transforms(transforms: Mapping[str, Any] | None):</span>
<span class="sd">        Imitates the method in CellMapImage, but does nothing for an EmptyImage object.</span>

<span class="sd">    Properties:</span>

<span class="sd">            bounding_box (None): Returns None.</span>
<span class="sd">            sampling_box (None): Returns None.</span>
<span class="sd">            bg_count (float): Returns zero.</span>
<span class="sd">            class_counts (float): Returns zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_class</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">target_scale</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">target_voxel_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">store</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;zyx&quot;</span><span class="p">,</span>
        <span class="n">empty_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes an empty image object.</span>

<span class="sd">        Args:</span>

<span class="sd">            target_class (str): The intended label class of the image.</span>
<span class="sd">            target_scale (Sequence[float]): The intended scale of the image in physical space.</span>
<span class="sd">            target_voxel_shape (Sequence[int]): The intended shape of the image in voxels.</span>
<span class="sd">            store (Optional[torch.Tensor], optional): The tensor to return. Defaults to None.</span>
<span class="sd">            axis_order (str, optional): The intended order of the axes in the image. Defaults to &quot;zyx&quot;.</span>
<span class="sd">            empty_value (float | int, optional): The value to fill the image with. Defaults to -100.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_class</span> <span class="o">=</span> <span class="n">target_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_scale</span> <span class="o">=</span> <span class="n">target_scale</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_voxel_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_order</span><span class="p">):</span>
            <span class="n">axis_order</span> <span class="o">=</span> <span class="n">axis_order</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">target_voxel_shape</span><span class="p">)</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">target_voxel_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axis_order</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_size</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">:</span> <span class="n">t</span> <span class="o">*</span> <span class="n">s</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axis_order</span><span class="p">,</span> <span class="n">target_voxel_shape</span><span class="p">,</span> <span class="n">target_scale</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="n">axis_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class_counts</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bg_count</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">sc</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_scale</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">empty_value</span> <span class="o">=</span> <span class="n">empty_value</span>
        <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">store</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">store</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">output_shape</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">])</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_value</span>
            <span class="p">)</span>

<div class="viewcode-block" id="EmptyImage.__getitem__">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.EmptyImage.__getitem__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the empty image data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the bounding box of the dataset. Returns None for an EmptyImage object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sampling_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sampling box of the dataset (i.e. where centers can be drawn from and still have full samples drawn from within the bounding box). Returns None for an EmptyImage object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bg_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of background pixels in the ground truth data, normalized by the resolution. Returns zero for an EmptyImage object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bg_count</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">class_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of pixels for the contained class in the ground truth data, normalized by the resolution. Returns zero for an EmptyImage object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_counts</span>

<div class="viewcode-block" id="EmptyImage.to">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.EmptyImage.to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Moves the image data to the given device.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span></div>


<div class="viewcode-block" id="EmptyImage.set_spatial_transforms">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.EmptyImage.set_spatial_transforms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_spatial_transforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transforms</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Imitates the method in CellMapImage, but does nothing for an EmptyImage object.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
</div>



<div class="viewcode-block" id="ImageWriter">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.ImageWriter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ImageWriter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is used to write image data to a single-resolution zarr.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        path (str): The path to the image file.</span>
<span class="sd">        label_class (str): The label class of the image.</span>
<span class="sd">        scale (Mapping[str, float]): The scale of the image in physical space.</span>
<span class="sd">        write_voxel_shape (Mapping[str, int]): The shape of data written to the image in voxels.</span>
<span class="sd">        axes (str): The order of the axes in the image.</span>
<span class="sd">        context (Optional[tensorstore.Context]): The context for the TensorStore.</span>

<span class="sd">    Methods:</span>
<span class="sd">        __setitem__(center: Mapping[str, float], data: torch.Tensor): Writes the given data to the image at the given center.</span>
<span class="sd">        __repr__() -&gt; str: Returns a string representation of the ImageWriter object.</span>

<span class="sd">    Properties:</span>

<span class="sd">        shape (Mapping[str, int]): Returns the shape of the image in voxels.</span>
<span class="sd">        center (Mapping[str, float]): Returns the center of the image in world units.</span>
<span class="sd">        full_coords: Returns the full coordinates of the image in world units.</span>
<span class="sd">        array_path (str): Returns the path to the single-scale image array.</span>
<span class="sd">        translation (Mapping[str, float]): Returns the translation of the image in world units.</span>
<span class="sd">        bounding_box (Mapping[str, list[float]]): Returns the bounding box of the dataset in world units.</span>
<span class="sd">        sampling_box (Mapping[str, list[float]]): Returns the sampling box of the dataset in world units.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">UPath</span><span class="p">,</span>
        <span class="n">label_class</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">bounding_box</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
        <span class="n">write_voxel_shape</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">scale_level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">axis_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;zyx&quot;</span><span class="p">,</span>
        <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tensorstore</span><span class="o">.</span><span class="n">Context</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes an ImageWriter object.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str): The path to the base folder of the multiscale image file.</span>
<span class="sd">            label_class (str): The label class of the image.</span>
<span class="sd">            scale_level (int): The multiscale level of the image. Defaults to 0.</span>
<span class="sd">            scale (Mapping[str, float]): The scale of the image in physical space.</span>
<span class="sd">            bounding_box (Mapping[str, list[float]]): The total region of interest for the image in world units. Example: {&quot;x&quot;: [12.0, 102.0], &quot;y&quot;: [12.0, 102.0], &quot;z&quot;: [12.0, 102.0]}.</span>
<span class="sd">            write_voxel_shape (Mapping[str, int]): The shape of data written to the image in voxels.</span>
<span class="sd">            axis_order (str, optional): The order of the axes in the image. Defaults to &quot;zyx&quot;.</span>
<span class="sd">            context (Optional[tensorstore.Context], optional): The context for the TensorStore. Defaults to None.</span>
<span class="sd">            overwrite (bool, optional): Whether to overwrite the image if it already exists. Defaults to False.</span>
<span class="sd">            dtype (np.dtype, optional): The data type of the image. Defaults to np.float32.</span>
<span class="sd">            fill_value (float | int, optional): The value to fill the empty image with before values are written. Defaults to 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">UPath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;s</span><span class="si">{</span><span class="n">scale_level</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_class</span> <span class="o">=</span> <span class="n">label_class</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_order</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axis_order</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axis_order</span><span class="p">,</span> <span class="n">scale</span><span class="p">)}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">write_voxel_shape</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_order</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">write_voxel_shape</span><span class="p">):</span>
                <span class="n">write_voxel_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">axis_order</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">write_voxel_shape</span><span class="p">)</span>
                <span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">write_voxel_shape</span><span class="p">)</span>
            <span class="n">write_voxel_shape</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">t</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axis_order</span><span class="p">,</span> <span class="n">write_voxel_shape</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_voxel_shape</span> <span class="o">=</span> <span class="n">write_voxel_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_world_shape</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">:</span> <span class="n">write_voxel_shape</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">axis_order</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="n">axis_order</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">write_voxel_shape</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_level</span> <span class="o">=</span> <span class="n">scale_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span> <span class="o">=</span> <span class="n">overwrite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>

        <span class="c1"># Create the new zarr&#39;s metadata</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">axis_order</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;offset&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="s2">&quot;axes&quot;</span><span class="p">:</span> <span class="n">dims</span><span class="p">,</span>
            <span class="s2">&quot;voxel_size&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;nanometer&quot;</span><span class="p">,</span>
            <span class="s2">&quot;chunk_shape&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">write_voxel_shape</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the image data as an xarray DataArray.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># Write multi-scale metadata</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">UPath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_path</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Add .zgroup files</span>
            <span class="n">group_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_path</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.zarr&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.zarr&quot;</span>
            <span class="c1"># print(group_path)</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">UPath</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_path</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.zarr&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">parts</span>
            <span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">group_path</span> <span class="o">=</span> <span class="n">UPath</span><span class="p">(</span><span class="n">group_path</span><span class="p">)</span> <span class="o">/</span> <span class="n">group</span>
                <span class="c1"># print(group_path)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">group_path</span> <span class="o">/</span> <span class="s2">&quot;.zgroup&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;{&quot;zarr_format&quot;: 2}&#39;</span><span class="p">)</span>
            <span class="n">create_multiscale_metadata</span><span class="p">(</span>
                <span class="n">ds_name</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_path</span><span class="p">),</span>
                <span class="n">voxel_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;voxel_size&quot;</span><span class="p">],</span>
                <span class="n">translation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;offset&quot;</span><span class="p">],</span>
                <span class="n">units</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">],</span>
                <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;axes&quot;</span><span class="p">],</span>
                <span class="n">base_scale_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_level</span><span class="p">,</span>
                <span class="n">levels_to_add</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">out_path</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">UPath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_path</span><span class="p">)</span> <span class="o">/</span> <span class="s2">&quot;.zattrs&quot;</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="c1"># Construct an xarray with Tensorstore backend</span>
            <span class="c1"># spec = xt._zarr_spec_from_path(self.path)</span>
            <span class="n">spec</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;driver&quot;</span><span class="p">:</span> <span class="s2">&quot;zarr&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kvstore&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;driver&quot;</span><span class="p">:</span> <span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="s2">&quot;path&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)},</span>
                <span class="c1"># &quot;transform&quot;: {</span>
                <span class="c1">#     &quot;input_labels&quot;: self.metadata[&quot;axes&quot;],</span>
                <span class="c1">#     # &quot;scale&quot;: self.metadata[&quot;voxel_size&quot;],</span>
                <span class="c1">#     &quot;input_inclusive_min&quot;: self.metadata[&quot;offset&quot;],</span>
                <span class="c1">#     &quot;input_shape&quot;: self.metadata[&quot;shape&quot;],</span>
                <span class="c1">#     # &quot;units&quot;: self.metadata[&quot;units&quot;],</span>
                <span class="c1"># },</span>
            <span class="p">}</span>
            <span class="n">open_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;read&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s2">&quot;write&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s2">&quot;create&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s2">&quot;delete_existing&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">overwrite</span><span class="p">,</span>
                <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                <span class="s2">&quot;fill_value&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="s2">&quot;chunk_layout&quot;</span><span class="p">:</span> <span class="n">tensorstore</span><span class="o">.</span><span class="n">ChunkLayout</span><span class="p">(</span>
                    <span class="n">write_chunk_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_shape</span>
                <span class="p">),</span>
                <span class="c1"># &quot;metadata&quot;: self.metadata,</span>
                <span class="c1"># &quot;transaction&quot;: tensorstore.Transaction(atomic=True),</span>
                <span class="s2">&quot;context&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">array_future</span> <span class="o">=</span> <span class="n">tensorstore</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
                <span class="n">spec</span><span class="p">,</span>
                <span class="o">**</span><span class="n">open_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array_future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;ALREADY_EXISTS&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Image already exists at </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">. Set overwrite=True to overwrite the image.&quot;</span>
                    <span class="p">)</span>
                <span class="ne">Warning</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="ne">UserWarning</span><span class="p">(</span><span class="s2">&quot;Falling back to zarr3 driver&quot;</span><span class="p">)</span>
                <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;driver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;zarr3&quot;</span>
                <span class="n">array_future</span> <span class="o">=</span> <span class="n">tensorstore</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">open_kwargs</span><span class="p">)</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array_future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">xt</span><span class="o">.</span><span class="n">_TensorStoreAdapter</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_array</span> <span class="o">=</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">full_coords</span><span class="p">)</span>

            <span class="c1"># Add .zattrs file</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">UPath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="o">/</span> <span class="s2">&quot;.zattrs&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Set the metadata for the Zarr array</span>
            <span class="c1"># ds = zarr.open_array(self.path)</span>
            <span class="c1"># for key, value in self.metadata.items():</span>
            <span class="c1">#     ds.attrs[key] = value</span>
            <span class="c1"># ds.attrs[&quot;_ARRAY_DIMENSIONS&quot;] = self.metadata[&quot;axes&quot;]</span>
            <span class="c1"># ds.attrs[&quot;dimension_units&quot;] = [</span>
            <span class="c1">#     f&quot;{s} {u}&quot;</span>
            <span class="c1">#     for s, u in zip(self.metadata[&quot;voxel_size&quot;], self.metadata[&quot;units&quot;])</span>
            <span class="c1"># ]</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">chunk_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the shape of the chunks for the image.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_shape</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">write_voxel_shape</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">world_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the shape of the image in world units.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_world_shape</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_world_shape</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">c</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_world_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the shape of the image in voxels.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">world_shape</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the center of the image in world units.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="n">center</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the offset of the image in world units.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">}</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the full coordinates of the image in world units.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_coords</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_full_coords</span> <span class="o">=</span> <span class="n">coords_from_transforms</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="p">[</span>
                    <span class="n">Axis</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                        <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;space&quot;</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s2">&quot;c&quot;</span> <span class="k">else</span> <span class="s2">&quot;channel&quot;</span><span class="p">,</span>
                        <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;nm&quot;</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s2">&quot;c&quot;</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
                <span class="p">],</span>
                <span class="n">transforms</span><span class="o">=</span><span class="p">(</span>
                    <span class="n">VectorScale</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">values</span><span class="p">())),</span>
                    <span class="n">VectorTranslation</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="o">.</span><span class="n">values</span><span class="p">())),</span>
                <span class="p">),</span>
                <span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_coords</span>

<div class="viewcode-block" id="ImageWriter.align_coords">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.ImageWriter.align_coords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">align_coords</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="c1"># TODO: Deprecate this function?</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Aligns the given coordinates to the image&#39;s coordinates.&quot;&quot;&quot;</span>
        <span class="n">aligned_coords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="c1"># Find the nearest coordinate in the image&#39;s actual coordinate grid</span>
            <span class="n">aligned_coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">][</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">])[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                    <span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">aligned_coords</span></div>


<div class="viewcode-block" id="ImageWriter.aligned_coords_from_center">
<a class="viewcode-back" href="../../cellmap_data.image.html#cellmap_data.ImageWriter.aligned_coords_from_center">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">aligned_coords_from_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the aligned coordinates for the given center with linear sequential coordinates aligned to the image&#39;s reference frame.&quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="c1"># Get index of closest start voxel to the edge of the write space, based on the center</span>
            <span class="n">start_requested</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_world_shape</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">start_aligned_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_requested</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="c1"># Get the aligned range of coordinates</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">][</span>
                <span class="n">start_aligned_idx</span> <span class="p">:</span> <span class="n">start_aligned_idx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_voxel_shape</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="n">coords</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">typing</span><span class="o">.</span><span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the given data to the image at the given center (in world units). Supports writing torch.Tensor, numpy.ndarray, and scalar data types, including for batches.&quot;&quot;&quot;</span>

        <span class="c1"># Find vectors of coordinates in world space to write data to if necessary</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">coords</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aligned_coords_from_center</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">coords</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># print(e)</span>
                <span class="c1"># print(data.shape)</span>
                <span class="c1"># print(</span>
                <span class="c1">#     f&quot;Writing to center {center} in image {self.path} failed. Coordinates: are not all within the image&#39;s bounds. Will drop out of bounds data.&quot;</span>
                <span class="c1"># )</span>
                <span class="c1"># Crop data to match the number of coordinates matched in the image</span>
                <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord</span><span class="p">)))</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">*</span><span class="n">slices</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">coords</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Write batches</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]])):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                    <span class="n">this_data</span> <span class="o">=</span> <span class="n">data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">this_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">[{</span><span class="n">c</span><span class="p">:</span> <span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">}]</span> <span class="o">=</span> <span class="n">this_data</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a string representation of the ImageWriter object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;ImageWriter(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">label_class</span><span class="si">}</span><span class="s2"> @ </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span></div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Jeff Rhoades
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
       Copyright 2024, Jeff Rhoades.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>