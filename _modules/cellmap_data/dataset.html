
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cellmap_data.dataset &#8212; CellMap-Data</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=e645c8fa"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/cellmap_data/dataset';</script>
    <link rel="icon" href="https://raw.githubusercontent.com/janelia-cellmap/cellmap-data/main/docs/source/_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="https://raw.githubusercontent.com/janelia-cellmap/cellmap-data/main/docs/source/_static/CellMapLogo.png" class="logo__image only-light" alt="CellMap-Data - Home"/>
    <script>document.write(`<img src="https://raw.githubusercontent.com/janelia-cellmap/cellmap-data/main/docs/source/_static/CellMapLogo.png" class="logo__image only-dark" alt="CellMap-Data - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../index.html">
                    CellMap-Data: the Docs
                </a>
            </li>
        </ul>
        
    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for cellmap_data.dataset</h1><div class="highlight"><pre>
<span></span><span class="c1"># %%</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Dataset</span>
<span class="kn">import</span> <span class="nn">tensorstore</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">CellMapImage</span><span class="p">,</span> <span class="n">EmptyImage</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="split_target_path">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.split_target_path">[docs]</a>
<span class="k">def</span> <span class="nf">split_target_path</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Splits a path to groundtruth data into the main path string, and the classes supplied for it.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">path_prefix</span><span class="p">,</span> <span class="n">path_rem</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)</span>
        <span class="n">classes</span><span class="p">,</span> <span class="n">path_suffix</span> <span class="o">=</span> <span class="n">path_rem</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)</span>
        <span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="n">path_string</span> <span class="o">=</span> <span class="n">path_prefix</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{label}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">path_suffix</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">path_string</span> <span class="o">=</span> <span class="n">path</span>
        <span class="n">classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">path_string</span><span class="p">,</span> <span class="n">classes</span></div>



<span class="c1"># %%</span>
<div class="viewcode-block" id="CellMapDataset">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset">[docs]</a>
<span class="k">class</span> <span class="nc">CellMapDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This subclasses PyTorch Dataset to load CellMap data for training. It maintains the same API as the Dataset class. Importantly, it maintains information about and handles for the sources for raw and groundtruth data. This information includes the path to the data, the classes for segmentation, and the arrays to input to the network and use as targets for the network predictions. The dataset constructs the sources for the raw and groundtruth data, and retrieves the data from the sources. The dataset also provides methods to get the number of pixels for each class in the ground truth data, normalized by the resolution. Additionally, random crops of the data can be generated for training, because the CellMapDataset maintains information about the extents of its source arrays. This object additionally combines images for different classes into a single output array, which is useful for training multiclass segmentation networks.</span>

<span class="sd">    Attributes:</span>

<span class="sd">        raw_path (str): The path to the raw image data.</span>
<span class="sd">        target_path (str): The path to the ground truth data.</span>
<span class="sd">        classes (Sequence[str]): A list of classes for segmentation training. Class order will be preserved in the output arrays. Classes not contained in the dataset will be filled in with the set &#39;empty_value&#39; and, optionally, zeros for true-negaties inferred from mutually exclusive classes indicated by the &#39;class_relation_dict&#39;.</span>
<span class="sd">        input_arrays (Mapping[str, Mapping[str, Sequence[int | float]]]): A dictionary containing the arrays of the dataset to input to the network. The dictionary should have the following structure::</span>

<span class="sd">            {</span>
<span class="sd">                &quot;array_name&quot;: {</span>
<span class="sd">                    &quot;shape&quot;: tuple[int],</span>
<span class="sd">                    &quot;scale&quot;: Sequence[float],</span>
<span class="sd">                },</span>
<span class="sd">                ...</span>
<span class="sd">            }</span>

<span class="sd">        where &#39;array_name&#39; is the name of the array, &#39;shape&#39; is the shape of the array in voxels, and &#39;scale&#39; is the scale of the array in world units.</span>
<span class="sd">        target_arrays (Mapping[str, Mapping[str, Sequence[int | float]]]): A dictionary containing the arrays of the dataset to use as targets for the network. The dictionary should have the same structure as &#39;input_arrays&#39;.</span>
<span class="sd">        spatial_transforms (Optional[Sequence[Mapping[str, any]]], optional): A sequence of dictionaries containing the spatial transformations to apply to the data. Defaults to None. The dictionary should have the following structure::</span>

<span class="sd">            {transform_name: {transform_args}}</span>

<span class="sd">        raw_value_transforms (Optional[Callable], optional): A function to apply to the raw data. Defaults to None. Example is to normalize the raw data.</span>
<span class="sd">        target_value_transforms (Optional[Callable | Sequence[Callable] | Mapping[str, Callable]], optional): A function to convert the ground truth data to target arrays. Defaults to None. Example is to convert the ground truth data to a signed distance transform. May be a single function, a list of functions, or a dictionary of functions for each class. In the case of a list of functions, it is assumed that the functions correspond to each class in the classes list in order. If the function is a dictionary, the keys should correspond to the classes in the &#39;classes&#39; list. The function should return a tensor of the same shape as the input tensor. Note that target transforms are applied to the ground truth data and should generally not be used with use of true-negative data inferred using the &#39;class_relations_dict&#39; (see below).</span>
<span class="sd">        class_relation_dict (Optional[Mapping[str, Sequence[str]]], optional): A dictionary of classes that are mutually exclusive. If a class is not present in the ground truth data, it will be inferred from the other classes in the dictionary. Defaults to None.</span>
<span class="sd">        is_train (bool, optional): Whether the dataset is for training, and thus should generate random spatial transforms, based on &#39;spatial_transforms&#39;. Defaults to False.</span>
<span class="sd">        axis_order (str, optional): The order of the axes in the dataset. Defaults to &quot;zyx&quot;.</span>
<span class="sd">        context (Optional[tensorstore.Context], optional): The TensorStore context for the image data. Defaults to None.</span>
<span class="sd">        rng (Optional[torch.Generator], optional): A random number generator. Defaults to None.</span>
<span class="sd">        force_has_data (bool, optional): Whether to force the dataset to report that it has data, regardless of existence of ground truth data. Useful for unsupervised training. Defaults to False.</span>
<span class="sd">        empty_value (float | int, optional): The value to fill in for empty data. Defaults to torch.nan.</span>
<span class="sd">        pad (bool, optional): Whether to pad the image data to match requested arrays. Defaults to False.</span>

<span class="sd">    Methods:</span>

<span class="sd">        get_empty_store: Returns an empty store for the dataset based on the requested array.</span>
<span class="sd">        get_target_array: Returns a target array source for the dataset, including the ability to infer true negatives from mutually exclusive classes.</span>
<span class="sd">        get_label_array: Returns a target array source for a specific class in the dataset.</span>
<span class="sd">        __len__: Returns the length of the dataset, determined by the number of coordinates that could be sampled as the center for an array request.</span>
<span class="sd">        __getitem__: Returns a crop of the input and target data as PyTorch tensors, corresponding to the coordinate of the unwrapped index.</span>
<span class="sd">        __repr__: Returns a string representation of the dataset.</span>
<span class="sd">        verify: Verifies that the dataset has data.</span>
<span class="sd">        get_indices: Returns the indices of the dataset that will produce non-overlapping tiles based on the requested chunk size.</span>
<span class="sd">        to: Moves the dataset to the specified device.</span>
<span class="sd">        generate_spatial_transforms: Generates random spatial transforms for the dataset when training and sets the current spatial transforms for all members of the dataset accordingly.</span>
<span class="sd">        set_raw_value_transforms: Sets the function for transforming raw data values in the dataset. For example, this can be used to normalize the raw data.</span>
<span class="sd">        set_target_value_transforms: Sets the function for transforming target data values in the dataset. For example, this can be used to convert ground truth data to a signed distance transform.</span>
<span class="sd">        reset_arrays: Sets the array specifications for the dataset to return on requests.</span>

<span class="sd">    Properties:</span>

<span class="sd">        center: Returns the center of the dataset in world units.</span>
<span class="sd">        largest_voxel_sizes: Returns the largest voxel size requested of the dataset.</span>
<span class="sd">        bounding_box: Returns the bounding box of the dataset.</span>
<span class="sd">        bounding_box_shape: Returns the shape of the bounding box of the dataset in voxels of the largest voxel size requested.</span>
<span class="sd">        sampling_box: Returns the sampling box of the dataset.</span>
<span class="sd">        sampling_box_shape: Returns the shape of the sampling box of the dataset in voxels of the largest voxel size requested.</span>
<span class="sd">        size: Returns the size of the dataset in voxels of the largest voxel size requested.</span>
<span class="sd">        class_counts: Returns the number of pixels for each class in the ground truth data, normalized by the resolution.</span>
<span class="sd">        class_weights: Returns the class weights for the dataset based on the number of samples in each class.</span>
<span class="sd">        validation_indices: Returns the indices of the dataset that will produce non-overlapping tiles for use in validation, based on the largest requested image view.</span>
<span class="sd">        device: Returns the device for the dataset.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CellMapDataset.__init__">
<a class="viewcode-back" href="../../cellmap_data.CellMapDataset.html#cellmap_data.CellMapDataset.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">raw_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># TODO: Switch &quot;raw_path&quot; to &quot;input_path&quot;</span>
        <span class="n">target_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">classes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">input_arrays</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]]],</span>
        <span class="n">target_arrays</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]]],</span>
        <span class="n">spatial_transforms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
        <span class="n">raw_value_transforms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target_value_transforms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Callable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">class_relation_dict</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">is_train</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">axis_order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;zyx&quot;</span><span class="p">,</span>
        <span class="n">context</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tensorstore</span><span class="o">.</span><span class="n">Context</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
        <span class="n">rng</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">force_has_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">empty_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">pad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the CellMapDataset class.</span>

<span class="sd">        Args:</span>
<span class="sd">            raw_path (str): The path to the raw data.</span>
<span class="sd">            target_path (str): The path to the ground truth data.</span>
<span class="sd">            classes (Sequence[str]): A list of classes for segmentation training. Class order will be preserved in the output arrays. Classes not contained in the dataset will be filled in with zeros.</span>
<span class="sd">            input_arrays (Mapping[str, Mapping[str, Sequence[int | float]]]): A dictionary containing the arrays of the dataset to input to the network. The dictionary should have the following structure::</span>

<span class="sd">                {</span>
<span class="sd">                    &quot;array_name&quot;: {</span>
<span class="sd">                        &quot;shape&quot;: tuple[int],</span>
<span class="sd">                        &quot;scale&quot;: Sequence[float],</span>
<span class="sd">                    },</span>
<span class="sd">                    ...</span>
<span class="sd">                }</span>

<span class="sd">            where &#39;array_name&#39; is the name of the array, &#39;shape&#39; is the shape of the array in voxels, and &#39;scale&#39; is the scale of the array in world units.</span>
<span class="sd">            target_arrays (Mapping[str, Mapping[str, Sequence[int | float]]]): A dictionary containing the arrays of the dataset to use as targets for the network. The dictionary should have the same structure as &#39;input_arrays&#39;.</span>
<span class="sd">            spatial_transforms (Optional[Mapping[str, Any]] = None, optional): A sequence of dictionaries containing the spatial transformations to apply to the data. Defaults to None. The dictionary should have the following structure::</span>

<span class="sd">                {transform_name: {transform_args}}</span>

<span class="sd">            raw_value_transforms (Optional[Callable], optional): A function to apply to the raw data. Defaults to None. Example is to normalize the raw data.</span>
<span class="sd">            target_value_transforms (Optional[Callable | Sequence[Callable] | Mapping[str, Callable]], optional): A function to convert the ground truth data to target arrays. Defaults to None. Example is to convert the ground truth data to a signed distance transform. May be a single function, a list of functions, or a dictionary of functions for each class. In the case of a list of functions, it is assumed that the functions correspond to each class in the classes list in order. If the function is a dictionary, the keys should correspond to the classes in the &#39;classes&#39; list. The function should return a tensor of the same shape as the input tensor. Note that target transforms are applied to the ground truth data and should generally not be used with use of true-negative data inferred using the &#39;class_relations_dict&#39;.</span>
<span class="sd">            is_train (bool, optional): Whether the dataset is for training. Defaults to False.</span>
<span class="sd">            context (Optional[tensorstore.Context], optional): The context for the image data. Defaults to None.</span>
<span class="sd">            rng (Optional[torch.Generator], optional): A random number generator. Defaults to None.</span>
<span class="sd">            force_has_data (bool, optional): Whether to force the dataset to report that it has data. Defaults to False.</span>
<span class="sd">            empty_value (float | int, optional): The value to fill in for empty data. Defaults to torch.nan.</span>
<span class="sd">            pad (bool, optional): Whether to pad the image data to match requested arrays. Defaults to False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_path</span> <span class="o">=</span> <span class="n">raw_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_paths</span> <span class="o">=</span> <span class="n">target_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_path_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_with_path</span> <span class="o">=</span> <span class="n">split_target_path</span><span class="p">(</span><span class="n">target_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classes</span> <span class="o">=</span> <span class="n">classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_arrays</span> <span class="o">=</span> <span class="n">input_arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_arrays</span> <span class="o">=</span> <span class="n">target_arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_transforms</span> <span class="o">=</span> <span class="n">spatial_transforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_value_transforms</span> <span class="o">=</span> <span class="n">raw_value_transforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_value_transforms</span> <span class="o">=</span> <span class="n">target_value_transforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_relation_dict</span> <span class="o">=</span> <span class="n">class_relation_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_train</span> <span class="o">=</span> <span class="n">is_train</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis_order</span> <span class="o">=</span> <span class="n">axis_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">rng</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_has_data</span> <span class="o">=</span> <span class="n">force_has_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">empty_value</span> <span class="o">=</span> <span class="n">empty_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad</span> <span class="o">=</span> <span class="n">pad</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_center</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_spatial_transforms</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_sources</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CellMapImage</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">array_name</span><span class="p">,</span> <span class="n">array_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_sources</span><span class="p">[</span><span class="n">array_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">CellMapImage</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw_path</span><span class="p">,</span>
                <span class="s2">&quot;raw&quot;</span><span class="p">,</span>
                <span class="n">array_info</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">],</span>
                <span class="n">array_info</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">],</span>  <span class="c1"># type: ignore</span>
                <span class="n">value_transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_value_transforms</span><span class="p">,</span>
                <span class="n">context</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
                <span class="n">pad</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">,</span>
                <span class="n">pad_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># inputs to the network should be padded with 0</span>
                <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
            <span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CellMapImage</span> <span class="o">|</span> <span class="n">EmptyImage</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">array_name</span><span class="p">,</span> <span class="n">array_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="p">[</span><span class="n">array_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_array</span><span class="p">(</span><span class="n">array_info</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the center of the dataset in world units.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">center</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="n">center</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">largest_voxel_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the largest voxel size of the dataset.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_largest_voxel_sizes</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">largest_voxel_size</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_order</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_sources</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">source</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
                            <span class="k">continue</span>
                        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># type: ignore</span>
                            <span class="n">largest_voxel_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">largest_voxel_size</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">size</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">source</span><span class="o">.</span><span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">largest_voxel_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">largest_voxel_size</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_largest_voxel_sizes</span> <span class="o">=</span> <span class="n">largest_voxel_size</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_largest_voxel_sizes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the bounding box of the dataset.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_sources</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;bounding_box&quot;</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_box_intersection</span><span class="p">(</span>
                            <span class="n">source</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">,</span> <span class="n">bounding_box</span>  <span class="c1"># type: ignore</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;bounding_box&quot;</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="n">bounding_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_box_intersection</span><span class="p">(</span>
                        <span class="n">source</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">,</span> <span class="n">bounding_box</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">bounding_box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Bounding box is None. This may result in errors when trying to sample from the dataset.&quot;</span>
                <span class="p">)</span>
                <span class="n">bounding_box</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_order</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounding_box_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the shape of the bounding box of the dataset in voxels of the largest voxel size requested.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box_shape</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_box_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sampling_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the sampling box of the dataset (i.e. where centers can be drawn from and still have full samples drawn from within the bounding box).&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">sampling_box</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_sources</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;sampling_box&quot;</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="n">sampling_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_box_intersection</span><span class="p">(</span>
                            <span class="n">source</span><span class="o">.</span><span class="n">sampling_box</span><span class="p">,</span> <span class="n">sampling_box</span>  <span class="c1"># type: ignore</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;sampling_box&quot;</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="n">sampling_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_box_intersection</span><span class="p">(</span>
                        <span class="n">source</span><span class="o">.</span><span class="n">sampling_box</span><span class="p">,</span> <span class="n">sampling_box</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">sampling_box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Sampling box is None. This may result in errors when trying to sample from the dataset.&quot;</span>
                <span class="p">)</span>
                <span class="n">sampling_box</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_order</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box</span> <span class="o">=</span> <span class="n">sampling_box</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sampling_box_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the shape of the sampling box of the dataset in voxels of the largest voxel size requested.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box_shape</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_box_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_box</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box_shape</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Sampling box shape is &lt;= 0 for axis </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2"> with size </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2">. Setting to 1&quot;</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box_shape</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_box_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the size of the dataset in voxels of the largest voxel size requested.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span>
                <span class="p">[</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">class_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of pixels for each class in the ground truth data, normalized by the resolution.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_counts</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">class_counts</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;totals&quot;</span><span class="p">:</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">}}</span>
            <span class="n">class_counts</span><span class="p">[</span><span class="s2">&quot;totals&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">c</span> <span class="o">+</span> <span class="s2">&quot;_bg&quot;</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">})</span>
            <span class="k">for</span> <span class="n">array_name</span><span class="p">,</span> <span class="n">sources</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">class_counts</span><span class="p">[</span><span class="n">array_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">CellMapImage</span><span class="p">):</span>
                        <span class="n">class_counts</span><span class="p">[</span><span class="n">array_name</span><span class="p">][</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="n">class_counts</span><span class="p">[</span><span class="n">array_name</span><span class="p">][</span><span class="n">label</span> <span class="o">+</span> <span class="s2">&quot;_bg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">class_counts</span><span class="p">[</span><span class="n">array_name</span><span class="p">][</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">class_counts</span>
                        <span class="n">class_counts</span><span class="p">[</span><span class="n">array_name</span><span class="p">][</span><span class="n">label</span> <span class="o">+</span> <span class="s2">&quot;_bg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">bg_count</span>
                        <span class="n">class_counts</span><span class="p">[</span><span class="s2">&quot;totals&quot;</span><span class="p">][</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="n">source</span><span class="o">.</span><span class="n">class_counts</span>
                        <span class="n">class_counts</span><span class="p">[</span><span class="s2">&quot;totals&quot;</span><span class="p">][</span><span class="n">label</span> <span class="o">+</span> <span class="s2">&quot;_bg&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">source</span><span class="o">.</span><span class="n">bg_count</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_class_counts</span> <span class="o">=</span> <span class="n">class_counts</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_counts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">class_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the class weights for the dataset based on the number of samples in each class. Classes without any samples will have a weight of NaN.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_weights</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">class_weights</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">c</span><span class="p">:</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">class_counts</span><span class="p">[</span><span class="s2">&quot;totals&quot;</span><span class="p">][</span><span class="n">c</span> <span class="o">+</span> <span class="s2">&quot;_bg&quot;</span><span class="p">]</span>
                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_counts</span><span class="p">[</span><span class="s2">&quot;totals&quot;</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_counts</span><span class="p">[</span><span class="s2">&quot;totals&quot;</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="k">else</span> <span class="mi">1</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_class_weights</span> <span class="o">=</span> <span class="n">class_weights</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_class_weights</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">validation_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the indices of the dataset that will produce non-overlapping tiles for use in validation, based on the largest requested voxel size.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validation_indices</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">chunk_size</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box_shape</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">chunk_size</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_box_shape</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validation_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validation_indices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the device for the dataset.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_device</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">mps</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;mps&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_device</span>

<div class="viewcode-block" id="CellMapDataset.__len__">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset.__len__">[docs]</a>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the length of the dataset, determined by the number of coordinates that could be sampled as the center for an array request.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_has_data</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_box_shape</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_order</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len</span></div>


<div class="viewcode-block" id="CellMapDataset.__getitem__">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a crop of the input and target data as PyTorch tensors, corresponding to the coordinate of the unwrapped index.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span>
                <span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_box_shape</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_order</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Index </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> out of bounds for dataset </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> of length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Returning closest index in bounds&quot;</span><span class="p">)</span>
            <span class="c1"># TODO: This is a hacky temprorary fix. Need to figure out why this is happening</span>
            <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_box_shape</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_order</span><span class="p">]</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">:</span> <span class="n">center</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">largest_voxel_sizes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_order</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_idx</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="n">spatial_transforms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_spatial_transforms</span><span class="p">()</span>
        <span class="c1"># TODO: Should do as many coordinate transformations as possible at the dataset level (duplicate reference frame images should have the same coordinate transformations) --&gt; do this per array, perhaps with CellMapArray object</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">array_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_arrays</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_sources</span><span class="p">[</span><span class="n">array_name</span><span class="p">]</span><span class="o">.</span><span class="n">set_spatial_transforms</span><span class="p">(</span><span class="n">spatial_transforms</span><span class="p">)</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_sources</span><span class="p">[</span><span class="n">array_name</span><span class="p">][</span><span class="n">center</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># TODO: Assumes 1 channel (i.e. grayscale)</span>
            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">outputs</span><span class="p">[</span><span class="n">array_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outputs</span><span class="p">[</span><span class="n">array_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>
        <span class="c1"># TODO: Allow for distribution of array gathering to multiple threads, perhaps with CellMapArray object</span>
        <span class="k">for</span> <span class="n">array_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_arrays</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">class_arrays</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">inferred_arrays</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="p">[</span><span class="n">array_name</span><span class="p">][</span><span class="n">label</span><span class="p">],</span> <span class="p">(</span><span class="n">CellMapImage</span><span class="p">,</span> <span class="n">EmptyImage</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="p">[</span><span class="n">array_name</span><span class="p">][</span>
                        <span class="n">label</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">set_spatial_transforms</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                        <span class="n">spatial_transforms</span>
                    <span class="p">)</span>
                    <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="p">[</span><span class="n">array_name</span><span class="p">][</span><span class="n">label</span><span class="p">][</span>
                        <span class="n">center</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>  <span class="c1"># type: ignore</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Add to list of arrays to infer</span>
                    <span class="n">inferred_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                    <span class="n">array</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">class_arrays</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>

            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">inferred_arrays</span><span class="p">:</span>
                <span class="c1"># Make array of true negatives</span>
                <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_empty_store</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">target_arrays</span><span class="p">[</span><span class="n">array_name</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span>
                <span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="k">for</span> <span class="n">other_label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="p">[</span><span class="n">array_name</span><span class="p">][</span><span class="n">label</span><span class="p">]:</span>  <span class="c1"># type: ignore</span>
                    <span class="k">if</span> <span class="n">class_arrays</span><span class="p">[</span><span class="n">other_label</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">class_arrays</span><span class="p">[</span><span class="n">other_label</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="n">array</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">class_arrays</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>

            <span class="n">outputs</span><span class="p">[</span><span class="n">array_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">class_arrays</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">outputs</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a string representation of the dataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;CellMapDataset(</span><span class="se">\n\t</span><span class="s2">Raw path: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_path</span><span class="si">}</span><span class="se">\n\t</span><span class="s2">GT path(s): </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target_paths</span><span class="si">}</span><span class="se">\n\t</span><span class="s2">Classes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="si">}</span><span class="s2">)&quot;</span>

<div class="viewcode-block" id="CellMapDataset.get_empty_store">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset.get_empty_store">[docs]</a>
    <span class="k">def</span> <span class="nf">get_empty_store</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">array_info</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an empty store, based on the requested array.&quot;&quot;&quot;</span>
        <span class="c1"># assert isinstance(</span>
        <span class="c1">#     self.empty_value, (float, int)</span>
        <span class="c1"># ), &quot;Empty value must be a number or NaN.&quot;</span>
        <span class="n">empty_store</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">array_info</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_value</span>
        <span class="k">return</span> <span class="n">empty_store</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="CellMapDataset.get_target_array">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset.get_target_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_target_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">array_info</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CellMapImage</span> <span class="o">|</span> <span class="n">EmptyImage</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a target array source for the dataset. Creates a dictionary of image sources for each class in the dataset. For classes that are not present in the ground truth data, the data can be inferred from the other classes in the dataset. This is useful for training segmentation networks with mutually exclusive classes.&quot;&quot;&quot;</span>
        <span class="n">empty_store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_empty_store</span><span class="p">(</span><span class="n">array_info</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">target_array</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">):</span>
            <span class="n">target_array</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_array</span><span class="p">(</span>
                <span class="n">label</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">array_info</span><span class="p">,</span> <span class="n">empty_store</span>
            <span class="p">)</span>
        <span class="c1"># Check to make sure we aren&#39;t trying to define true negatives with non-existent images</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_array</span><span class="p">[</span><span class="n">label</span><span class="p">],</span> <span class="p">(</span><span class="n">CellMapImage</span><span class="p">,</span> <span class="n">EmptyImage</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="n">is_empty</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">other_label</span> <span class="ow">in</span> <span class="n">target_array</span><span class="p">[</span><span class="n">label</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">other_label</span> <span class="ow">in</span> <span class="n">target_array</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">target_array</span><span class="p">[</span><span class="n">other_label</span><span class="p">],</span> <span class="n">CellMapImage</span>
                <span class="p">):</span>
                    <span class="n">is_empty</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">is_empty</span><span class="p">:</span>
                <span class="n">target_array</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">EmptyImage</span><span class="p">(</span>
                    <span class="n">label</span><span class="p">,</span> <span class="n">array_info</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">],</span> <span class="n">array_info</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">],</span> <span class="n">empty_store</span>  <span class="c1"># type: ignore</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">target_array</span></div>


<div class="viewcode-block" id="CellMapDataset.get_label_array">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset.get_label_array">[docs]</a>
    <span class="k">def</span> <span class="nf">get_label_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">array_info</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="n">empty_store</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CellMapImage</span> <span class="o">|</span> <span class="n">EmptyImage</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a target array source for a specific class in the dataset.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classes_with_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_value_transforms</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">value_transform</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_value_transforms</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_value_transforms</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">value_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_value_transforms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_value_transforms</span>  <span class="c1"># type: ignore</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">CellMapImage</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_path_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">),</span>
                <span class="n">label</span><span class="p">,</span>
                <span class="n">array_info</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">],</span>
                <span class="n">array_info</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">],</span>  <span class="c1"># type: ignore</span>
                <span class="n">value_transform</span><span class="o">=</span><span class="n">value_transform</span><span class="p">,</span>
                <span class="n">context</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
                <span class="n">pad</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">,</span>
                <span class="n">pad_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">empty_value</span><span class="p">,</span>
                <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">class_counts</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">class_relation_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_relation_dict</span>
            <span class="p">):</span>
                <span class="c1"># Add lookup of source images for true-negatives in absence of annotations</span>
                <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_relation_dict</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">EmptyImage</span><span class="p">(</span>
                    <span class="n">label</span><span class="p">,</span> <span class="n">array_info</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">],</span> <span class="n">array_info</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">],</span> <span class="n">empty_store</span>  <span class="c1"># type: ignore</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">array</span></div>


    <span class="k">def</span> <span class="nf">_get_box_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_box</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the shape of the box in voxels of the largest voxel size requested.&quot;&quot;&quot;</span>
        <span class="n">box_shape</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="n">source_box</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="n">size</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">largest_voxel_sizes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="n">box_shape</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">box_shape</span>

    <span class="k">def</span> <span class="nf">_get_box_intersection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source_box</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">current_box</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the intersection of the source and current boxes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">source_box</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current_box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">source_box</span>
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="n">source_box</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">assert</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Invalid box: </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">stop</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">current_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">current_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="p">)</span>
                <span class="n">current_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">current_box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">stop</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_box</span>

<div class="viewcode-block" id="CellMapDataset.verify">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset.verify">[docs]</a>
    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Verifies that the dataset is valid to draw samples from.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: make more robust</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># print(e)</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="CellMapDataset.get_indices">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset.get_indices">[docs]</a>
    <span class="k">def</span> <span class="nf">get_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the indices of the dataset that will tile the dataset according to the chunk_size.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: ADD TEST</span>
        <span class="c1"># Get padding per axis</span>
        <span class="n">indices_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">chunk_size</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">indices_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_box_shape</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Generate linear indices by unraveling all combinations of axes indices</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">indices_dict</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_order</span><span class="p">]):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices_dict</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_order</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_box_shape</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indices</span></div>


<div class="viewcode-block" id="CellMapDataset.to">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset.to">[docs]</a>
    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;CellMapDataset&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the device for the dataset.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_sources</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;to&quot;</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="n">source</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;to&quot;</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">source</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="CellMapDataset.generate_spatial_transforms">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset.generate_spatial_transforms">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_spatial_transforms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;When &#39;self.is_train&#39; is True, generates random spatial transforms for the dataset, based on the user specified transforms.</span>

<span class="sd">        Available spatial transforms:</span>
<span class="sd">            - &quot;mirror&quot;: Mirrors the data along the specified axes. Parameters are the probabilities of mirroring along each axis, formatted as a dictionary of axis: probability pairs. Example: {&quot;mirror&quot;: {&quot;axes&quot;: {&quot;x&quot;: 0.5, &quot;y&quot;: 0.5, &quot;z&quot;:0.1}}} will mirror the data along the x and y axes with a 50% probability, and along the z axis with a 10% probability.</span>
<span class="sd">            - &quot;transpose&quot;: Transposes the data along the specified axes. Parameters are the axes to transpose, formatted as a list. Example: {&quot;transpose&quot;: {&quot;axes&quot;: [&quot;x&quot;, &quot;z&quot;]}} will randomly transpose the data along the x and z axes.</span>
<span class="sd">            - &quot;rotate&quot;: Rotates the data around the specified axes within the specified angle ranges. Parameters are the axes to rotate and the angle ranges, formatted as a dictionary of axis: [min_angle, max_angle] pairs. Example: {&quot;rotate&quot;: {&quot;axes&quot;: {&quot;x&quot;: [-180,180], &quot;y&quot;: [-180,180], &quot;z&quot;:[-180,180]}} will rotate the data around the x, y, and z axes from 180 to -180 degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_train</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_transforms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">spatial_transforms</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">transform</span><span class="p">,</span> <span class="n">params</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_transforms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;mirror&quot;</span><span class="p">:</span>
                <span class="c1"># input: &quot;mirror&quot;: {&quot;axes&quot;: {&quot;x&quot;: 0.5, &quot;y&quot;: 0.5, &quot;z&quot;:0.1}}</span>
                <span class="c1"># output: {&quot;mirror&quot;: [&quot;x&quot;, &quot;y&quot;]}</span>
                <span class="n">spatial_transforms</span><span class="p">[</span><span class="n">transform</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;axes&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">prob</span><span class="p">:</span>
                        <span class="n">spatial_transforms</span><span class="p">[</span><span class="n">transform</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;transpose&quot;</span><span class="p">:</span>
                <span class="c1"># only reorder axes specified in params</span>
                <span class="c1"># input: &quot;transpose&quot;: {&quot;axes&quot;: [&quot;x&quot;, &quot;z&quot;]}</span>
                <span class="c1"># params[&quot;axes&quot;] = [&quot;x&quot;, &quot;z&quot;]</span>
                <span class="c1"># axes = {&quot;x&quot;: 0, &quot;y&quot;: 1, &quot;z&quot;: 2}</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="p">{</span><span class="n">axis</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_order</span><span class="p">)}</span>
                <span class="c1"># shuffled_axes = [0, 2]</span>
                <span class="n">shuffled_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;axes&quot;</span><span class="p">]]</span>
                <span class="c1"># shuffled_axes = [2, 0]</span>
                <span class="n">shuffled_axes</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">shuffled_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shuffled_axes</span><span class="p">),</span> <span class="n">generator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rng</span><span class="p">)</span>
                <span class="p">]</span>  <span class="c1"># shuffle indices</span>
                <span class="c1"># shuffled_axes = {&quot;x&quot;: 2, &quot;z&quot;: 0}</span>
                <span class="n">shuffled_axes</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">axis</span><span class="p">:</span> <span class="n">shuffled_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;axes&quot;</span><span class="p">])</span>
                <span class="p">}</span>  <span class="c1"># reassign axes</span>
                <span class="c1"># axes = {&quot;x&quot;: 2, &quot;y&quot;: 1, &quot;z&quot;: 0}</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">shuffled_axes</span><span class="p">)</span>
                <span class="c1"># output: {&quot;transpose&quot;: {&quot;x&quot;: 2, &quot;y&quot;: 1, &quot;z&quot;: 0}}</span>
                <span class="n">spatial_transforms</span><span class="p">[</span><span class="n">transform</span><span class="p">]</span> <span class="o">=</span> <span class="n">axes</span>
            <span class="k">elif</span> <span class="n">transform</span> <span class="o">==</span> <span class="s2">&quot;rotate&quot;</span><span class="p">:</span>
                <span class="c1"># input: &quot;rotate&quot;: {&quot;axes&quot;: {&quot;x&quot;: [-180,180], &quot;y&quot;: [-180,180], &quot;z&quot;:[-180,180]}}</span>
                <span class="c1"># output: {&quot;rotate&quot;: {&quot;x&quot;: 45, &quot;y&quot;: 90, &quot;z&quot;: 0}}</span>
                <span class="n">spatial_transforms</span><span class="p">[</span><span class="n">transform</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">limits</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;axes&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">spatial_transforms</span><span class="p">[</span><span class="n">transform</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span>
                        <span class="mi">1</span><span class="p">,</span> <span class="n">generator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rng</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                    <span class="n">spatial_transforms</span><span class="p">[</span><span class="n">transform</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">spatial_transforms</span><span class="p">[</span><span class="n">transform</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="o">+</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown spatial transform: </span><span class="si">{</span><span class="n">transform</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_spatial_transforms</span> <span class="o">=</span> <span class="n">spatial_transforms</span>
        <span class="k">return</span> <span class="n">spatial_transforms</span></div>


<div class="viewcode-block" id="CellMapDataset.set_raw_value_transforms">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset.set_raw_value_transforms">[docs]</a>
    <span class="k">def</span> <span class="nf">set_raw_value_transforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transforms</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the raw value transforms for the dataset.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_value_transforms</span> <span class="o">=</span> <span class="n">transforms</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_sources</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">source</span><span class="o">.</span><span class="n">value_transform</span> <span class="o">=</span> <span class="n">transforms</span></div>


<div class="viewcode-block" id="CellMapDataset.set_target_value_transforms">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset.set_target_value_transforms">[docs]</a>
    <span class="k">def</span> <span class="nf">set_target_value_transforms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transforms</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the ground truth value transforms for the dataset.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_value_transforms</span> <span class="o">=</span> <span class="n">transforms</span>
        <span class="k">for</span> <span class="n">sources</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">CellMapImage</span><span class="p">):</span>
                    <span class="n">source</span><span class="o">.</span><span class="n">value_transform</span> <span class="o">=</span> <span class="n">transforms</span></div>


<div class="viewcode-block" id="CellMapDataset.reset_arrays">
<a class="viewcode-back" href="../../cellmap_data.dataset.html#cellmap_data.CellMapDataset.reset_arrays">[docs]</a>
    <span class="k">def</span> <span class="nf">reset_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;target&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the arrays for the dataset to return.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;input&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_sources</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">array_name</span><span class="p">,</span> <span class="n">array_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">input_sources</span><span class="p">[</span><span class="n">array_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">CellMapImage</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">raw_path</span><span class="p">,</span>
                    <span class="s2">&quot;raw&quot;</span><span class="p">,</span>
                    <span class="n">array_info</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">],</span>
                    <span class="n">array_info</span><span class="p">[</span><span class="s2">&quot;shape&quot;</span><span class="p">],</span>  <span class="c1"># type: ignore</span>
                    <span class="n">value_transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">raw_value_transforms</span><span class="p">,</span>
                    <span class="n">context</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
                    <span class="n">pad</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pad</span><span class="p">,</span>
                    <span class="n">pad_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># inputs to the network should be padded with 0</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">array_name</span><span class="p">,</span> <span class="n">array_info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_sources</span><span class="p">[</span><span class="n">array_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_array</span><span class="p">(</span><span class="n">array_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown dataset array type: </span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
</div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Jeff Rhoades
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
       Copyright 2024, Jeff Rhoades.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>